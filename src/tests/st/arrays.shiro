//! run

fn takes_view(range: view[i32]) -> i32 {
    return range[0] + range[1];
}

fn main() -> i32 {
    // Fixed-size array declaration
    var fixed_array: [i32, 5] = uninit;

    // Array indexing and assignment
    var i = 0;
    while (i < 5) {
        fixed_array[i] = 10 * (i + 1);
        i += 1;
    }
    fixed_array[0] = 0;

    // Array element access
    var sum = fixed_array[0] + fixed_array[1];
    printI32(sum);  //! stdout: "20"

    // Create views from parts of the array
    var view1 = fixed_array[0..2];  // First 2 elements
    var view2 = fixed_array[1..4];  // Elements 1 through 3
    var view3 = view2[1..];         // Elements 2 through 3

    // Passing arrays to functions that take views
    var result1 = takes_view(fixed_array);
    printI32(result1);  //! stdout: "20"
    var result2 = takes_view(view1);
    printI32(result2);  //! stdout: "20"

    // Pointers to arrays
    var ptr_fixed: [i32, 5]* = &fixed_array;  //! warning: "type annotation is superfluous"

    // Array element access through pointer
    (*ptr_fixed)[0] = 100;

    // Getting raw pointer to array start
    var raw_ptr: i32* = &fixed_array[0];  //! warning: "type annotation is superfluous"
    raw_ptr[2] = 200;  // bounds unchecked

    // Multi-dimensional arrays
    var multi_dim = [[1, 2, 3], [4, 5, 6]];

    var total = multi_dim[0][0] + multi_dim[1][2];
    printI32(total);  //! stdout: "7"

    // Array indexing is done with usize but implicit conversion is liberal for indexing
    var arr: [i32, 10] = uninit;

    // COERCION_SIGNEDNESS: i64 -> usize (signed -> unsigned, same size on 64-bit)
    var idx_i64 = 5i64;
    arr[idx_i64] = 100;

    // COERCION_WIDEN: u8 -> usize
    var idx_u8 = 3u8;
    arr[idx_u8] = 200;

    // COERCION_SIGNEDNESS + WIDEN: i16 -> usize
    var idx_i16 = 7i16;
    arr[idx_i16] = 300;

    printI32(arr[3]);  //! stdout: "200"
    printI32(arr[5]);  //! stdout: "100"
    printI32(arr[7]);  //! stdout: "300"

    return 0;
}
